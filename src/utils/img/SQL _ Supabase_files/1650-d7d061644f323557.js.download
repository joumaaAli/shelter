"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1650],{38264:function(e,n,t){var a=t(52322),_=t(6277);n.Z=e=>{let{options:n,width:t=50,activeOption:r,onClickOption:i,borderOverride:c="border-stronger"}=e,l=e=>"absolute top-0 z-1 text-xs inline-flex h-full items-center justify-center font-medium\n    ".concat(e?"hover:text-foreground-light hover:text-foreground":"hover:text-foreground"," hover:text-foreground focus:z-10 focus:outline-none focus:border-blue-300 focus:ring-blue\n    transition ease-in-out duration-150");return(0,a.jsxs)("div",{className:"relative border ".concat(c," rounded-md h-7"),style:{padding:1,width:(t+1)*2},children:[(0,a.jsx)("span",{style:{width:t,translate:r===n[1]?"0px":"".concat(t-2,"px")},"aria-hidden":"true",className:(0,_.default)("z-0 inline-block rounded h-full bg-overlay-hover shadow transform","transition-all ease-in-out border border-strong")}),n.map((e,n)=>(0,a.jsx)("span",{style:{width:t+1},className:"\n              ".concat(r===e?"text-foreground":"text-foreground-light","\n              ").concat(0===n?"right-0":"left-0","\n              ").concat(l(r===e),"\n              cursor-pointer\n            "),onClick:()=>i(e),children:(0,a.jsx)("span",{className:(0,_.default)("capitalize hover:text-foreground",r===e?"text-foreground":"text-foreground-light"),children:e})},"toggle_".concat(n)))]})}},68871:function(e,n,t){t.d(n,{k:function(){return i},N:function(){return _}});var a,_,r=t(75539);let i=t.n(r)()("\n      DROP TYPE IF EXISTS pg_temp.tabledefs CASCADE;\n      CREATE TYPE pg_temp.tabledefs AS ENUM ('PKEY_INTERNAL','PKEY_EXTERNAL','FKEYS_INTERNAL', 'FKEYS_EXTERNAL', 'COMMENTS', 'FKEYS_NONE', 'INCLUDE_TRIGGERS', 'NO_TRIGGERS');\n      \n      -- SELECT * FROM pg_temp.pg_get_coldef('sample','orders','id');\n      -- DROP FUNCTION pg_temp.pg_get_coldef(text,text,text,boolean);\n      CREATE OR REPLACE FUNCTION pg_temp.pg_get_coldef(\n        in_schema text,\n        in_table  text,\n        in_column text,\n        oldway    boolean default False\n      )\n      RETURNS text\n      LANGUAGE plpgsql VOLATILE\n      AS\n      $$\n      DECLARE\n      v_coldef     text;\n      v_dt1        text;\n      v_dt2        text;\n      v_dt3        text;\n      v_nullable   boolean;\n      v_position   int; \n      v_identity   text; \n      v_generated  text; \n      v_hasdflt    boolean; \n      v_dfltexpr   text;\n      \n      BEGIN\n        IF oldway THEN \n          SELECT pg_catalog.format_type(a.atttypid, a.atttypmod) INTO v_coldef FROM pg_namespace n, pg_class c, pg_attribute a, pg_type t \n          WHERE n.nspname = in_schema AND n.oid = c.relnamespace AND c.relname = in_table AND a.attname = in_column and a.attnum > 0 AND a.attrelid = c.oid AND a.atttypid = t.oid ORDER BY a.attnum;\n          -- RAISE NOTICE 'DEBUG: oldway=%',v_coldef;\n        ELSE\n          -- a.attrelid::regclass::text, a.attname\n          SELECT CASE WHEN a.atttypid = ANY ('{int,int8,int2}'::regtype[]) AND EXISTS (SELECT FROM pg_attrdef ad WHERE ad.adrelid = a.attrelid AND ad.adnum   = a.attnum AND \n          pg_get_expr(ad.adbin, ad.adrelid) = 'nextval(''' || (pg_get_serial_sequence (a.attrelid::regclass::text, a.attname))::regclass || '''::regclass)') THEN CASE a.atttypid \n          WHEN 'int'::regtype  THEN 'serial' WHEN 'int8'::regtype THEN 'bigserial' WHEN 'int2'::regtype THEN 'smallserial' END ELSE format_type(a.atttypid, a.atttypmod) END AS data_type  \n          INTO v_coldef FROM pg_namespace n, pg_class c, pg_attribute a, pg_type t \n          WHERE n.nspname = in_schema AND n.oid = c.relnamespace AND c.relname = in_table AND a.attname = in_column and a.attnum > 0 AND a.attrelid = c.oid AND a.atttypid = t.oid ORDER BY a.attnum;\n          -- RAISE NOTICE 'DEBUG: newway=%',v_coldef;\n      \n          -- Issue#24: not implemented yet	  \n          -- might replace with this below to do more detailed parsing...\n          -- SELECT a.atttypid::regtype AS dt1, format_type(a.atttypid, a.atttypmod) as dt2, t.typname as dt3, CASE WHEN not(a.attnotnull) THEN True ELSE False END AS nullable, \n          -- a.attnum, a.attidentity, a.attgenerated, a.atthasdef, pg_get_expr(ad.adbin, ad.adrelid) dfltexpr \n          -- INTO v_dt1, v_dt2, v_dt3, v_nullable, v_position, v_identity, v_generated, v_hasdflt, v_dfltexpr \n          -- FROM pg_attribute a JOIN pg_class c ON (a.attrelid = c.oid) JOIN pg_type t ON (a.atttypid = t.oid) LEFT JOIN pg_attrdef ad ON (a.attrelid = ad.adrelid AND a.attnum = ad.adnum) \n          -- WHERE c.relkind in ('r','p') AND a.attnum > 0 AND NOT a.attisdropped AND c.relnamespace::regnamespace::text = in_schema AND c.relname = in_table AND a.attname = in_column;\n          -- RAISE NOTICE 'schema=%  table=%  column=%  dt1=%  dt2=%  dt3=%  nullable=%  pos=%  identity=%   generated=%  HasDefault=%  DeftExpr=%', in_schema, in_table, in_column, v_dt1,v_dt2,v_dt3,v_nullable,v_position,v_identity,v_generated,v_hasdflt,v_dfltexpr;\n        END IF;\n        RETURN v_coldef;\n      END;\n      $$;\n      \n      -- SELECT * FROM pg_temp.pg_get_tabledef('sample', 'address', false);\n      DROP FUNCTION IF EXISTS pg_temp.pg_get_tabledef(character varying,character varying,boolean,tabledefs[]);\n      CREATE OR REPLACE FUNCTION pg_temp.pg_get_tabledef(\n        in_schema varchar,\n        in_table varchar,\n        _verbose boolean,\n        VARIADIC arr pg_temp.tabledefs[] DEFAULT '{}':: pg_temp.tabledefs[]\n      )\n      RETURNS text\n      LANGUAGE plpgsql VOLATILE\n      AS\n      $$\n        DECLARE\n          v_qualified text := '';\n          v_table_ddl text;\n          v_table_oid int;\n          v_colrec record;\n          v_constraintrec record;\n          v_trigrec       record;\n          v_indexrec record;\n          v_rec           record;\n          v_constraint_name text;\n          v_constraint_def  text;\n          v_pkey_def        text := '';\n          v_fkey_def        text := '';\n          v_fkey_defs       text := '';\n          v_trigger text := '';\n          v_partition_key text := '';\n          v_partbound text;\n          v_parent text;\n          v_parent_schema text;\n          v_persist text;\n          v_temp  text := ''; \n          v_temp2 text;\n          v_relopts text;\n          v_tablespace text;\n          v_pgversion int;\n          bSerial boolean;\n          bPartition boolean;\n          bInheritance boolean;\n          bRelispartition boolean;\n          constraintarr text[] := '{}';\n          constraintelement text;\n          bSkip boolean;\n          bVerbose boolean := False;\n          v_cnt1   integer;\n          v_cnt2   integer;\n          search_path_old text := '';\n          search_path_new text := '';\n          v_partial    boolean;\n          v_pos        integer;\n      \n          -- assume defaults for ENUMs at the getgo	\n          pkcnt            int := 0;\n          fkcnt            int := 0;\n          trigcnt          int := 0;\n          cmtcnt           int := 0;\n          pktype           pg_temp.tabledefs := 'PKEY_INTERNAL';\n          fktype           pg_temp.tabledefs := 'FKEYS_INTERNAL';\n          trigtype         pg_temp.tabledefs := 'NO_TRIGGERS';\n          arglen           integer;\n          vargs            text;\n          avarg            pg_temp.tabledefs;\n      \n          -- exception variables\n          v_ret            text;\n          v_diag1          text;\n          v_diag2          text;\n          v_diag3          text;\n          v_diag4          text;\n          v_diag5          text;\n          v_diag6          text;\n        \n        BEGIN\n          SET client_min_messages = 'notice';\n          IF _verbose THEN bVerbose = True; END IF;\n          \n          -- v17 fix: handle case-sensitive  \n          -- v_qualified = in_schema || '.' || in_table;\n        \n          arglen := array_length($4, 1);\n          IF arglen IS NULL THEN\n              -- nothing to do, so assume defaults\n              NULL;\n          ELSE\n              -- loop thru args\n              -- IF 'NO_TRIGGERS' = ANY ($4)\n              -- select array_to_string($4, ',', '***') INTO vargs;\n              IF bVerbose THEN RAISE NOTICE 'arguments=%', $4; END IF;\n              FOREACH avarg IN ARRAY $4 LOOP\n                  IF bVerbose THEN RAISE NOTICE 'arg=%', avarg; END IF;\n                  IF avarg = 'FKEYS_INTERNAL' OR avarg = 'FKEYS_EXTERNAL' OR avarg = 'FKEYS_NONE' THEN\n                      fkcnt = fkcnt + 1;\n                      fktype = avarg;\n                  ELSEIF avarg = 'INCLUDE_TRIGGERS' OR avarg = 'NO_TRIGGERS' THEN\n                      trigcnt = trigcnt + 1;\n                      trigtype = avarg;\n                  ELSEIF avarg = 'PKEY_EXTERNAL' THEN\n                      pkcnt = pkcnt + 1;\n                      pktype = avarg;				                \n                  ELSEIF avarg = 'COMMENTS' THEN\n                      cmtcnt = cmtcnt + 1;\n                      \n                  END IF;\n              END LOOP;\n              IF fkcnt > 1 THEN \n                  RAISE WARNING 'Only one foreign key option can be provided. You provided %', fkcnt;\n                  RETURN '';\n              ELSEIF trigcnt > 1 THEN \n                  RAISE WARNING 'Only one trigger option can be provided. You provided %', trigcnt;\n                  RETURN '';\n              ELSEIF pkcnt > 1 THEN \n                  RAISE WARNING 'Only one pkey option can be provided. You provided %', pkcnt;\n                  RETURN '';			\n              ELSEIF cmtcnt > 1 THEN \n                  RAISE WARNING 'Only one comments option can be provided. You provided %', cmtcnt;\n                  RETURN '';			\n                  \n              END IF;		   		   \n          END IF;\n      \n          SELECT c.oid, (select setting from pg_settings where name = 'server_version_num') INTO v_table_oid, v_pgversion FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n          WHERE c.relkind in ('r','p') AND c.relname = in_table AND n.nspname = in_schema;\n      \n        -- set search_path = public before we do anything to force explicit schema qualification but dont forget to set it back before exiting...\n          SELECT setting INTO search_path_old FROM pg_settings WHERE name = 'search_path';\n      \n          -- RAISE NOTICE 'DEBUG tableddl: saving old search_path: ***%***', search_path_old;\n          EXECUTE 'SET search_path = \"public\"';\n          SELECT setting INTO search_path_new FROM pg_settings WHERE name = 'search_path';\n          -- RAISE NOTICE 'DEBUG tableddl: using new search path=***%***', search_path_new;\n          \n          -- throw an error if table was not found\n          IF (v_table_oid IS NULL) THEN\n            RAISE EXCEPTION 'table does not exist';\n          END IF;\n      \n          -- get user-defined tablespaces if applicable\n          SELECT tablespace INTO v_temp FROM pg_tables WHERE schemaname = in_schema and tablename = in_table and tablespace IS NOT NULL;\n          IF v_temp IS NULL THEN\n            v_tablespace := 'TABLESPACE pg_default';\n          ELSE\n            v_tablespace := 'TABLESPACE ' || v_temp;\n          END IF;\n          \n          -- also see if there are any SET commands for this table, ie, autovacuum_enabled=off, fillfactor=70\n          WITH relopts AS (SELECT unnest(c.reloptions) relopts FROM pg_class c, pg_namespace n WHERE n.nspname = in_schema and n.oid = c.relnamespace and c.relname = in_table) \n          SELECT string_agg(r.relopts, ', ') as relopts INTO v_temp from relopts r;\n          IF v_temp IS NULL THEN\n            v_relopts := '';\n          ELSE\n            v_relopts := ' WITH (' || v_temp || ')';\n          END IF;\n          \n          -- -----------------------------------------------------------------------------------\n          -- Create table defs for partitions/children using inheritance or declarative methods.\n          -- inheritance: pg_class.relkind = 'r'   pg_class.relispartition=false   pg_class.relpartbound is NULL\n          -- declarative: pg_class.relkind = 'r'   pg_class.relispartition=true    pg_class.relpartbound is NOT NULL\n          -- -----------------------------------------------------------------------------------\n          v_partbound := '';\n          bPartition := False;\n          bInheritance := False;\n          IF v_pgversion < 100000 THEN\n            -- Issue#11: handle parent schema\n            SELECT c2.relname parent, c2.relnamespace::regnamespace INTO v_parent, v_parent_schema from pg_class c1, pg_namespace n, pg_inherits i, pg_class c2\n            WHERE n.nspname = in_schema and n.oid = c1.relnamespace and c1.relname = in_table and c1.oid = i.inhrelid and i.inhparent = c2.oid and c1.relkind = 'r';      \n            IF (v_parent IS NOT NULL) THEN\n              bPartition   := True;\n              bInheritance := True;\n            END IF;\n          ELSE\n            -- Issue#11: handle parent schema\n            SELECT c2.relname parent, c1.relispartition, pg_get_expr(c1.relpartbound, c1.oid, true), c2.relnamespace::regnamespace INTO v_parent, bRelispartition, v_partbound, v_parent_schema from pg_class c1, pg_namespace n, pg_inherits i, pg_class c2\n            WHERE n.nspname = in_schema and n.oid = c1.relnamespace and c1.relname = in_table and c1.oid = i.inhrelid and i.inhparent = c2.oid and c1.relkind = 'r';\n            IF (v_parent IS NOT NULL) THEN\n              bPartition   := True;\n              IF bRelispartition THEN\n                bInheritance := False;\n              ELSE\n                bInheritance := True;\n              END IF;\n            END IF;\n          END IF;\n          IF bPartition THEN\n            --Issue#17 fix for case-sensitive tables\n            -- SELECT count(*) INTO v_cnt1 FROM information_schema.tables t WHERE EXISTS (SELECT REGEXP_MATCHES(s.table_name, '([A-Z]+)','g') FROM information_schema.tables s \n            -- WHERE t.table_schema=s.table_schema AND t.table_name=s.table_name AND t.table_schema = quote_ident(in_schema) AND t.table_name = quote_ident(in_table) AND t.table_type = 'BASE TABLE');      \n            SELECT count(*) INTO v_cnt1 FROM information_schema.tables t WHERE EXISTS (SELECT REGEXP_MATCHES(s.table_name, '([A-Z]+)','g') FROM information_schema.tables s \n            WHERE t.table_schema=s.table_schema AND t.table_name=s.table_name AND t.table_schema = in_schema AND t.table_name = in_table AND t.table_type = 'BASE TABLE');      		  \n            \n            --Issue#19 put double-quotes around SQL keyword column names\n            -- Issue#121: fix keyword lookup for table name not column name that does not apply here\n            -- SELECT COUNT(*) INTO v_cnt2 FROM pg_get_keywords() WHERE word = v_colrec.column_name AND catcode = 'R';\n            SELECT COUNT(*) INTO v_cnt2 FROM pg_get_keywords() WHERE word = in_table AND catcode = 'R';\n            \n            IF bInheritance THEN\n              -- inheritance-based\n              IF v_cnt1 > 0 OR v_cnt2 > 0 THEN\n                v_table_ddl := 'CREATE TABLE ' || in_schema || '.\"' || in_table || '\"( '|| E'\\n';        \n              ELSE\n                v_table_ddl := 'CREATE TABLE ' || in_schema || '.' || in_table || '( '|| E'\\n';                \n              END IF;\n      \n              -- Jump to constraints section to add the check constraints\n            ELSE\n              -- declarative-based\n              IF v_relopts <> '' THEN\n                IF v_cnt1 > 0 OR v_cnt2 > 0 THEN\n                  v_table_ddl := 'CREATE TABLE ' || in_schema || '.\"' || in_table || '\" PARTITION OF ' || in_schema || '.' || v_parent || ' ' || v_partbound || v_relopts || ' ' || v_tablespace || '; ' || E'\\n';\n                ELSE\n                  v_table_ddl := 'CREATE TABLE ' || in_schema || '.' || in_table || ' PARTITION OF ' || in_schema || '.' || v_parent || ' ' || v_partbound || v_relopts || ' ' || v_tablespace || '; ' || E'\\n';\n                END IF;\n              ELSE\n                IF v_cnt1 > 0 OR v_cnt2 > 0 THEN\n                  v_table_ddl := 'CREATE TABLE ' || in_schema || '.\"' || in_table || '\" PARTITION OF ' || in_schema || '.' || v_parent || ' ' || v_partbound || ' ' || v_tablespace || '; ' || E'\\n';\n                ELSE\n                  v_table_ddl := 'CREATE TABLE ' || in_schema || '.' || in_table || ' PARTITION OF ' || in_schema || '.' || v_parent || ' ' || v_partbound || ' ' || v_tablespace || '; ' || E'\\n';\n                END IF;\n              END IF;\n              -- Jump to constraints and index section to add the check constraints and indexes and perhaps FKeys\n            END IF;\n          END IF;\n          IF bVerbose THEN RAISE NOTICE '(1)tabledef so far: %', v_table_ddl; END IF;\n      \n          IF NOT bPartition THEN\n            -- see if this is unlogged or temporary table\n            select c.relpersistence into v_persist from pg_class c, pg_namespace n where n.nspname = in_schema and n.oid = c.relnamespace and c.relname = in_table and c.relkind = 'r';\n            IF v_persist = 'u' THEN\n              v_temp := 'UNLOGGED';\n            ELSIF v_persist = 't' THEN\n              v_temp := 'TEMPORARY';\n            ELSE\n              v_temp := '';\n            END IF;\n          END IF;\n          \n          -- start the create definition for regular tables unless we are in progress creating an inheritance-based child table\n          IF NOT bPartition THEN\n            --Issue#17 fix for case-sensitive tables\n            -- SELECT count(*) INTO v_cnt1 FROM information_schema.tables t WHERE EXISTS (SELECT REGEXP_MATCHES(s.table_name, '([A-Z]+)','g') FROM information_schema.tables s \n            -- WHERE t.table_schema=s.table_schema AND t.table_name=s.table_name AND t.table_schema = quote_ident(in_schema) AND t.table_name = quote_ident(in_table) AND t.table_type = 'BASE TABLE');   \n            SELECT count(*) INTO v_cnt1 FROM information_schema.tables t WHERE EXISTS (SELECT REGEXP_MATCHES(s.table_name, '([A-Z]+)','g') FROM information_schema.tables s \n            WHERE t.table_schema=s.table_schema AND t.table_name=s.table_name AND t.table_schema = in_schema AND t.table_name = in_table AND t.table_type = 'BASE TABLE');         \n            IF v_cnt1 > 0 THEN\n              v_table_ddl := 'CREATE ' || v_temp || ' TABLE ' || in_schema || '.\"' || in_table || '\" (' || E'\\n';\n            ELSE\n              v_table_ddl := 'CREATE ' || v_temp || ' TABLE ' || in_schema || '.' || in_table || ' (' || E'\\n';\n            END IF;\n          END IF;\n          -- RAISE NOTICE 'DEBUG2: tabledef so far: %', v_table_ddl;    \n          -- define all of the columns in the table unless we are in progress creating an inheritance-based child table\n          IF NOT bPartition THEN\n            FOR v_colrec IN\n              SELECT c.column_name, c.data_type, c.udt_name, c.udt_schema, c.character_maximum_length, c.is_nullable, c.column_default, c.numeric_precision, c.numeric_scale, c.is_identity, c.identity_generation, c.is_generated, c.generation_expression        \n              FROM information_schema.columns c WHERE (table_schema, table_name) = (in_schema, in_table) ORDER BY ordinal_position\n            LOOP\n              IF bVerbose THEN RAISE NOTICE '(col loop) name=%  type=%  udt_name=%  default=%  is_generated=%  gen_expr=%', v_colrec.column_name, v_colrec.data_type, v_colrec.udt_name, v_colrec.column_default, v_colrec.is_generated, v_colrec.generation_expression; END IF;  \n              \n              -- v17 fix: handle case-sensitive for pg_get_serial_sequence that requires SQL Identifier handling\n              -- SELECT CASE WHEN pg_get_serial_sequence(v_qualified, v_colrec.column_name) IS NOT NULL THEN True ELSE False END into bSerial;\n              SELECT CASE WHEN pg_get_serial_sequence(quote_ident(in_schema) || '.' || quote_ident(in_table), v_colrec.column_name) IS NOT NULL THEN True ELSE False END into bSerial;\n              IF bVerbose THEN\n                -- v17 fix: handle case-sensitive for pg_get_serial_sequence that requires SQL Identifier handling\n                -- SELECT pg_get_serial_sequence(v_qualified, v_colrec.column_name) into v_temp;\n                SELECT pg_get_serial_sequence(quote_ident(in_schema) || '.' || quote_ident(in_table), v_colrec.column_name) into v_temp;\n                IF v_temp IS NULL THEN v_temp = 'NA'; END IF;\n                SELECT pg_temp.pg_get_coldef(in_schema, in_table,v_colrec.column_name) INTO v_diag1;\n                RAISE NOTICE 'DEBUG table: %  Column: %  datatype: %  Serial=%  serialval=%  coldef=%', v_qualified, v_colrec.column_name, v_colrec.data_type, bSerial, v_temp, v_diag1;\n                RAISE NOTICE 'DEBUG tabledef: %', v_table_ddl;\n              END IF;\n              \n              --Issue#17 put double-quotes around case-sensitive column names\n              SELECT COUNT(*) INTO v_cnt1 FROM information_schema.columns t WHERE EXISTS (SELECT REGEXP_MATCHES(s.column_name, '([A-Z]+)','g') FROM information_schema.columns s \n              WHERE t.table_schema=s.table_schema and t.table_name=s.table_name and t.column_name=s.column_name AND t.table_schema = quote_ident(in_schema) AND column_name = v_colrec.column_name);         \n      \n              --Issue#19 put double-quotes around SQL keyword column names         \n              SELECT COUNT(*) INTO v_cnt2 FROM pg_get_keywords() WHERE word = v_colrec.column_name AND catcode = 'R';\n              \n              IF v_cnt1 > 0 OR v_cnt2 > 0 THEN\n                v_table_ddl := v_table_ddl || '  \"' || v_colrec.column_name || '\" ';\n              ELSE\n                v_table_ddl := v_table_ddl || '  ' || v_colrec.column_name || ' ';\n              END IF;\n      \n              -- Issue#23: Handle autogenerated columns and rewrite as a simpler IF THEN ELSE branch instead of a much more complex embedded CASE STATEMENT\n              IF v_colrec.is_generated = 'ALWAYS' and v_colrec.generation_expression IS NOT NULL THEN\n                  -- searchable tsvector GENERATED ALWAYS AS (to_tsvector('simple'::regconfig, COALESCE(translate(email, '@.-'::citext, ' '::text), ''::text)) ) STORED\n                  v_temp = v_colrec.data_type || ' GENERATED ALWAYS AS (' || v_colrec.generation_expression || ') STORED ';\n              ELSEIF v_colrec.udt_name in ('geometry', 'box2d', 'box2df', 'box3d', 'geography', 'geometry_dump', 'gidx', 'spheroid', 'valid_detail') THEN\n                  v_temp = v_colrec.udt_name;\n              ELSEIF v_colrec.data_type = 'USER-DEFINED' THEN\n                  v_temp = v_colrec.udt_schema || '.' || v_colrec.udt_name;\n              ELSEIF v_colrec.data_type = 'ARRAY' THEN\n                    -- Issue#6 fix: handle arrays\n                  v_temp = pg_temp.pg_get_coldef(in_schema, in_table,v_colrec.column_name);\n                  -- v17 fix: handle case-sensitive for pg_get_serial_sequence that requires SQL Identifier handling\n                  -- WHEN pg_get_serial_sequence(v_qualified, v_colrec.column_name) IS NOT NULL \n              ELSEIF pg_get_serial_sequence(quote_ident(in_schema) || '.' || quote_ident(in_table), v_colrec.column_name) IS NOT NULL THEN\n                  -- Issue#8 fix: handle serial. Note: NOT NULL is implied so no need to declare it explicitly\n                  v_temp = pg_temp.pg_get_coldef(in_schema, in_table,v_colrec.column_name);\n              ELSE\n                  v_temp = v_colrec.data_type;\n              END IF;\n              -- RAISE NOTICE 'column def1=%', v_temp;\n      \n              -- handle IDENTITY columns\n              IF v_colrec.is_identity = 'YES' THEN\n                  IF v_colrec.identity_generation = 'ALWAYS' THEN \n                      v_temp = v_temp || ' GENERATED ALWAYS AS IDENTITY';\n                  ELSE\n                      v_temp = v_temp || ' GENERATED BY DEFAULT AS IDENTITY';\n                  END IF;\n              ELSEIF v_colrec.character_maximum_length IS NOT NULL THEN \n                  v_temp = v_temp || ('(' || v_colrec.character_maximum_length || ')');\n              ELSEIF v_colrec.numeric_precision > 0 AND v_colrec.numeric_scale > 0 THEN \n                  v_temp = v_temp || '(' || v_colrec.numeric_precision || ',' || v_colrec.numeric_scale || ')';\n              END IF;\n      \n              -- Handle NULL/NOT NULL\n              IF bSerial THEN \n                  v_temp = v_temp || ' NOT NULL';\n              ELSEIF v_colrec.is_nullable = 'NO' THEN \n                  v_temp = v_temp || ' NOT NULL';\n              ELSEIF v_colrec.is_nullable = 'YES' THEN\n                  v_temp = v_temp || ' NULL';\n              END IF;\n      \n              -- Handle defaults\n              IF v_colrec.column_default IS NOT null AND NOT bSerial THEN \n                  -- RAISE NOTICE 'Setting default for column, %', v_colrec.column_name;\n                  v_temp = v_temp || (' DEFAULT ' || v_colrec.column_default);\n              END IF;\n              v_temp = v_temp || ',' || E'\\n';\n              -- RAISE NOTICE 'column def2=%', v_temp;\n              v_table_ddl := v_table_ddl || v_temp;\n              -- RAISE NOTICE 'tabledef=%', v_table_ddl;\n      \n            END LOOP;\n          END IF;\n          IF bVerbose THEN RAISE NOTICE '(2)tabledef so far: %', v_table_ddl; END IF;\n              \n          -- define all the constraints: conparentid does not exist pre PGv11\n          IF v_pgversion < 110000 THEN\n            FOR v_constraintrec IN\n              SELECT con.conname as constraint_name, con.contype as constraint_type,\n                CASE\n                  WHEN con.contype = 'p' THEN 1 -- primary key constraint\n                  WHEN con.contype = 'u' THEN 2 -- unique constraint\n                  WHEN con.contype = 'f' THEN 3 -- foreign key constraint\n                  WHEN con.contype = 'c' THEN 4\n                  ELSE 5\n                END as type_rank,\n                pg_get_constraintdef(con.oid) as constraint_definition\n              FROM pg_catalog.pg_constraint con JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid JOIN pg_catalog.pg_namespace nsp ON nsp.oid = connamespace\n              WHERE nsp.nspname = in_schema AND rel.relname = in_table ORDER BY type_rank\n            LOOP\n              v_constraint_name := v_constraintrec.constraint_name;\n              v_constraint_def  := v_constraintrec.constraint_definition;\n              IF v_constraintrec.type_rank = 1 THEN\n                  IF pkcnt = 0 OR pktype = 'PKEY_INTERNAL' THEN\n                      -- internal def\n                      v_constraint_name := v_constraintrec.constraint_name;\n                      v_constraint_def  := v_constraintrec.constraint_definition;\n                      v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\n                        || 'CONSTRAINT' || ' '\n                        || v_constraint_name || ' '\n                        || v_constraint_def\n                        || ',' || E'\\n';\n                  ELSE\n                    -- Issue#16 handle external PG def\n                    SELECT 'ALTER TABLE ONLY ' || in_schema || '.' || c.relname || ' ADD CONSTRAINT ' || r.conname || ' ' || pg_catalog.pg_get_constraintdef(r.oid, true) || ';' INTO v_pkey_def \n                    FROM pg_catalog.pg_constraint r, pg_class c, pg_namespace n where r.conrelid = c.oid and  r.contype = 'p' and n.oid = r.connamespace and n.nspname = in_schema AND c.relname = in_table and r.conname = v_constraint_name;             \n                  END IF;\n                  IF bPartition THEN\n                    continue;\n                  END IF;\n              ELSIF v_constraintrec.type_rank = 3 THEN\n                  -- handle foreign key constraints\n                  --Issue#22 fix: added FKEY_NONE check\n                  IF fktype = 'FKEYS_NONE' THEN\n                      -- skip\n                      continue;\n                  ELSIF fkcnt = 0 OR fktype = 'FKEYS_INTERNAL' THEN\n                      -- internal def\n                      v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\n                        || 'CONSTRAINT' || ' '\n                        || v_constraint_name || ' '\n                        || v_constraint_def\n                        || ',' || E'\\n';                \n                  ELSE\n                      -- external def\n                      SELECT 'ALTER TABLE ONLY ' || n.nspname || '.' || c2.relname || ' ADD CONSTRAINT ' || r.conname || ' ' || pg_catalog.pg_get_constraintdef(r.oid, true) || ';' INTO v_fkey_def \n                      FROM pg_constraint r, pg_class c1, pg_namespace n, pg_class c2 where r.conrelid = c1.oid and  r.contype = 'f' and n.nspname = in_schema and n.oid = r.connamespace and r.conrelid = c2.oid and c2.relname = in_table;\n                      v_fkey_defs = v_fkey_defs || v_fkey_def || E'\\n';\n                  END IF;\n              ELSE\n                  -- handle all other constraints besides PKEY and FKEYS as internal defs by default\n                  v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\n                    || 'CONSTRAINT' || ' '\n                    || v_constraint_name || ' '\n                    || v_constraint_def\n                    || ',' || E'\\n';            \n              END IF;\n              if bVerbose THEN RAISE NOTICE 'DEBUG4: constraint name=% constraint_def=%', v_constraint_name,v_constraint_def; END IF;\n              constraintarr := constraintarr || v_constraintrec.constraint_name:: text;\n        \n            END LOOP;\n          ELSE\n            -- handle PG versions 11 and up\n            -- Issue#20: Fix logic for external PKEY and FKEYS\n            FOR v_constraintrec IN\n              SELECT con.conname as constraint_name, con.contype as constraint_type,\n                CASE\n                  WHEN con.contype = 'p' THEN 1 -- primary key constraint\n                  WHEN con.contype = 'u' THEN 2 -- unique constraint\n                  WHEN con.contype = 'f' THEN 3 -- foreign key constraint\n                  WHEN con.contype = 'c' THEN 4\n                  ELSE 5\n                END as type_rank,\n                pg_get_constraintdef(con.oid) as constraint_definition\n              FROM pg_catalog.pg_constraint con JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid JOIN pg_catalog.pg_namespace nsp ON nsp.oid = connamespace\n              WHERE nsp.nspname = in_schema AND rel.relname = in_table \n                    --Issue#13 added this condition:\n                    AND con.conparentid = 0 \n                    ORDER BY type_rank\n            LOOP\n              v_constraint_name := v_constraintrec.constraint_name;\n              v_constraint_def  := v_constraintrec.constraint_definition;\n              IF v_constraintrec.type_rank = 1 THEN\n                  IF pkcnt = 0 OR pktype = 'PKEY_INTERNAL' THEN\n                      -- internal def\n                      v_constraint_name := v_constraintrec.constraint_name;\n                      v_constraint_def  := v_constraintrec.constraint_definition;\n                      v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\n                        || 'CONSTRAINT' || ' '\n                        || v_constraint_name || ' '\n                        || v_constraint_def\n                        || ',' || E'\\n';\n                  ELSE\n                    -- Issue#16 handle external PG def\n                    SELECT 'ALTER TABLE ONLY ' || in_schema || '.' || c.relname || ' ADD CONSTRAINT ' || r.conname || ' ' || pg_catalog.pg_get_constraintdef(r.oid, true) || ';' INTO v_pkey_def \n                    FROM pg_catalog.pg_constraint r, pg_class c, pg_namespace n where r.conrelid = c.oid and  r.contype = 'p' and n.oid = r.connamespace and n.nspname = in_schema AND c.relname = in_table;              \n                  END IF;\n                  IF bPartition THEN\n                    continue;\n                  END IF;\n              ELSIF v_constraintrec.type_rank = 3 THEN\n                  -- handle foreign key constraints\n                  --Issue#22 fix: added FKEY_NONE check\n                  IF fktype = 'FKEYS_NONE' THEN\n                      -- skip\n                      continue;            \n                  ELSIF fkcnt = 0 OR fktype = 'FKEYS_INTERNAL' THEN\n                      -- internal def\n                      v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\n                        || 'CONSTRAINT' || ' '\n                        || v_constraint_name || ' '\n                        || v_constraint_def\n                        || ',' || E'\\n';                \n                  ELSE\n                      -- external def\n                      SELECT 'ALTER TABLE ONLY ' || n.nspname || '.' || c2.relname || ' ADD CONSTRAINT ' || r.conname || ' ' || pg_catalog.pg_get_constraintdef(r.oid, true) || ';' INTO v_fkey_def \n                      FROM pg_constraint r, pg_class c1, pg_namespace n, pg_class c2 where r.conrelid = c1.oid and  r.contype = 'f' and n.nspname = in_schema and n.oid = r.connamespace and r.conrelid = c2.oid and c2.relname = in_table and \n                      r.conname = v_constraint_name and r.conparentid = 0;\n                      v_fkey_defs = v_fkey_defs || v_fkey_def || E'\\n';\n                  END IF;\n              ELSE\n                  -- handle all other constraints besides PKEY and FKEYS as internal defs by default\n                  v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\n                    || 'CONSTRAINT' || ' '\n                    || v_constraint_name || ' '\n                    || v_constraint_def\n                    || ',' || E'\\n';            \n              END IF;\n              if bVerbose THEN RAISE NOTICE 'DEBUG4: constraint name=% constraint_def=%', v_constraint_name,v_constraint_def; END IF;\n              constraintarr := constraintarr || v_constraintrec.constraint_name:: text;\n        \n            END LOOP;\n          END IF;      \n        \n          -- drop the last comma before ending the create statement, which should be right before the carriage return character\n          -- Issue#24: make sure the comma is there before removing it\n          select substring(v_table_ddl, length(v_table_ddl) - 1, 1) INTO v_temp;\n          IF v_temp = ',' THEN\n              v_table_ddl = substr(v_table_ddl, 0, length(v_table_ddl) - 1) || E'\\n';\n          END IF;\n          IF bVerbose THEN RAISE NOTICE '(3)tabledef so far: %', trim(v_table_ddl); END IF;\n      \n          -- ---------------------------------------------------------------------------\n          -- at this point we have everything up to the last table-enclosing parenthesis\n          -- ---------------------------------------------------------------------------\n          IF bVerbose THEN RAISE NOTICE '(4)tabledef so far: %', v_table_ddl; END IF;\n      \n          -- See if this is an inheritance-based child table and finish up the table create.\n          IF bPartition and bInheritance THEN\n            -- Issue#11: handle parent schema\n            -- v_table_ddl := v_table_ddl || ') INHERITS (' || in_schema || '.' || v_parent || ') ' || E'\\n' || v_relopts || ' ' || v_tablespace || ';' || E'\\n';\n            IF v_parent_schema = '' OR v_parent_schema IS NULL THEN v_parent_schema = in_schema; END IF;\n            v_table_ddl := v_table_ddl || ') INHERITS (' || v_parent_schema || '.' || v_parent || ') ' || E'\\n' || v_relopts || ' ' || v_tablespace || ';' || E'\\n';\n          END IF;\n      \n          IF v_pgversion >= 100000 AND NOT bPartition and NOT bInheritance THEN\n            -- See if this is a partitioned table (pg_class.relkind = 'p') and add the partitioned key \n            SELECT pg_get_partkeydef(c1.oid) as partition_key INTO v_partition_key FROM pg_class c1 JOIN pg_namespace n ON (n.oid = c1.relnamespace) LEFT JOIN pg_partitioned_table p ON (c1.oid = p.partrelid) \n            WHERE n.nspname = in_schema and n.oid = c1.relnamespace and c1.relname = in_table and c1.relkind = 'p';\n      \n            IF v_partition_key IS NOT NULL AND v_partition_key <> '' THEN\n              -- add partition clause\n              -- NOTE:  cannot specify default tablespace for partitioned relations\n              -- v_table_ddl := v_table_ddl || ') PARTITION BY ' || v_partition_key || ' ' || v_tablespace || ';' || E'\\n';  \n              v_table_ddl := v_table_ddl || ') PARTITION BY ' || v_partition_key || ';' || E'\\n';  \n            ELSEIF v_relopts <> '' THEN\n              v_table_ddl := v_table_ddl || ') ' || v_relopts || ' ' || v_tablespace || ';' || E'\\n';  \n            ELSE\n              -- end the create definition\n              v_table_ddl := v_table_ddl || ') ' || v_tablespace || ';' || E'\\n';    \n            END IF;  \n          END IF;\n      \n          IF bVerbose THEN RAISE NOTICE '(5)tabledef so far: %', v_table_ddl; END IF;\n          \n          -- Add closing paren for regular tables\n          -- IF NOT bPartition THEN\n          -- v_table_ddl := v_table_ddl || ') ' || v_relopts || ' ' || v_tablespace || E';\\n';  \n          -- END IF;\n          -- RAISE NOTICE 'ddlsofar3: %', v_table_ddl;\n      \n          -- Issue#16 create the external PKEY def if indicated\n          IF v_pkey_def <> '' THEN\n              v_table_ddl := v_table_ddl || v_pkey_def || E'\\n';    \n          END IF;\n        \n          -- Issue#20\n          IF v_fkey_defs <> '' THEN\n                v_table_ddl := v_table_ddl || v_fkey_defs || E'\\n';    \n          END IF;\n        \n          IF bVerbose THEN RAISE NOTICE '(6)tabledef so far: %', v_table_ddl; END IF;\n        \n          -- create indexes\n          FOR v_indexrec IN\n            SELECT indexdef, COALESCE(tablespace, 'pg_default') as tablespace, indexname FROM pg_indexes WHERE (schemaname, tablename) = (in_schema, in_table)\n          LOOP\n            -- RAISE NOTICE 'DEBUG6: indexname=%  indexdef=%', v_indexrec.indexname, v_indexrec.indexdef;             \n            -- loop through constraints and skip ones already defined\n            bSkip = False;\n            FOREACH constraintelement IN ARRAY constraintarr\n            LOOP \n              IF constraintelement = v_indexrec.indexname THEN\n                  -- RAISE NOTICE 'DEBUG7: skipping index, %', v_indexrec.indexname;\n                  bSkip = True;\n                  EXIT;\n              END IF;\n            END LOOP;   \n            if bSkip THEN CONTINUE; END IF;\n            \n            -- Add IF NOT EXISTS clause so partition index additions will not be created if declarative partition in effect and index already created on parent\n            v_indexrec.indexdef := REPLACE(v_indexrec.indexdef, 'CREATE INDEX', 'CREATE INDEX IF NOT EXISTS');\n            -- Fix Issue#26: do it for unique/primary key indexes as well\n            v_indexrec.indexdef := REPLACE(v_indexrec.indexdef, 'CREATE UNIQUE INDEX', 'CREATE UNIQUE INDEX IF NOT EXISTS');\n            -- RAISE NOTICE 'DEBUG8: adding index, %', v_indexrec.indexname;\n            \n            -- NOTE:  cannot specify default tablespace for partitioned relations\n            IF v_partition_key IS NOT NULL AND v_partition_key <> '' THEN\n                v_table_ddl := v_table_ddl || v_indexrec.indexdef || ';' || E'\\n';\n            ELSE\n                -- Issue#25: see if partial index or not\n                select CASE WHEN i.indpred IS NOT NULL THEN True ELSE False END INTO v_partial \n                FROM pg_index i JOIN pg_class c1 ON (i.indexrelid = c1.oid) JOIN pg_class c2 ON (i.indrelid = c2.oid) \n                WHERE c1.relnamespace::regnamespace::text = in_schema AND c2.relnamespace::regnamespace::text = in_schema AND c2.relname = in_table AND c1.relname = v_indexrec.indexname; \n                IF v_partial THEN\n                    -- Put tablespace def before WHERE CLAUSE\n                    v_temp = v_indexrec.indexdef;\n                    v_pos = POSITION(' WHERE ' IN v_temp);\n                    v_temp2 = SUBSTRING(v_temp, v_pos);\n                    v_temp  = SUBSTRING(v_temp, 1, v_pos);\n                    v_table_ddl := v_table_ddl || v_temp || ' TABLESPACE ' || v_indexrec.tablespace || v_temp2 || ';' || E'\\n';              \n                ELSE\n                    v_table_ddl := v_table_ddl || v_indexrec.indexdef || ' TABLESPACE ' || v_indexrec.tablespace || ';' || E'\\n';\n                END IF;\n            END IF;\n            \n          END LOOP;\n          IF bVerbose THEN RAISE NOTICE '(7)tabledef so far: %', v_table_ddl; END IF;\n      \n          -- Issue#20: added logic for table and column comments\n          IF  cmtcnt > 0 THEN \n              FOR v_rec IN\n                SELECT c.relname, 'COMMENT ON ' || CASE WHEN c.relkind in ('r','p') AND a.attname IS NULL THEN 'TABLE ' WHEN c.relkind in ('r','p') AND a.attname IS NOT NULL THEN 'COLUMN ' WHEN c.relkind = 'f' THEN 'FOREIGN TABLE ' \n                      WHEN c.relkind = 'm' THEN 'MATERIALIZED VIEW ' WHEN c.relkind = 'v' THEN 'VIEW ' WHEN c.relkind = 'i' THEN 'INDEX ' WHEN c.relkind = 'S' THEN 'SEQUENCE ' ELSE 'XX' END || n.nspname || '.' || \n                      CASE WHEN c.relkind in ('r','p') AND a.attname IS NOT NULL THEN quote_ident(c.relname) || '.' || a.attname ELSE quote_ident(c.relname) END || ' IS '   || quote_literal(d.description) || ';' as ddl\n                FROM pg_class c JOIN pg_namespace n ON (n.oid = c.relnamespace) LEFT JOIN pg_description d ON (c.oid = d.objoid) LEFT JOIN pg_attribute a ON (c.oid = a.attrelid AND a.attnum > 0 and a.attnum = d.objsubid)\n                WHERE d.description IS NOT NULL AND n.nspname = in_schema AND c.relname = in_table ORDER BY 2 desc, ddl\n              LOOP\n                  --RAISE NOTICE 'comments:%', v_rec.ddl;\n                  v_table_ddl = v_table_ddl || v_rec.ddl || E'\\n';\n              END LOOP;   \n          END IF;\n          IF bVerbose THEN RAISE NOTICE '(8)tabledef so far: %', v_table_ddl; END IF;\n        \n          IF trigtype = 'INCLUDE_TRIGGERS' THEN\n            -- Issue#14: handle multiple triggers for a table\n            FOR v_trigrec IN\n                select pg_get_triggerdef(t.oid, True) || ';' as triggerdef FROM pg_trigger t, pg_class c, pg_namespace n \n                WHERE n.nspname = in_schema and n.oid = c.relnamespace and c.relname = in_table and c.relkind = 'r' and t.tgrelid = c.oid and NOT t.tgisinternal\n            LOOP\n                v_table_ddl := v_table_ddl || v_trigrec.triggerdef;\n                v_table_ddl := v_table_ddl || E'\\n';          \n                IF bVerbose THEN RAISE NOTICE 'triggerdef = %', v_trigrec.triggerdef; END IF;\n            END LOOP;       	    \n          END IF;\n        \n          IF bVerbose THEN RAISE NOTICE '(9)tabledef so far: %', v_table_ddl; END IF;\n          -- add empty line\n          v_table_ddl := v_table_ddl || E'\\n';\n          IF bVerbose THEN RAISE NOTICE '(10)tabledef so far: %', v_table_ddl; END IF;\n          \n          -- reset search_path back to what it was\n          IF search_path_old = '' THEN\n            SELECT set_config('search_path', '', false) into v_temp;\n          ELSE\n            EXECUTE 'SET search_path = ' || search_path_old;\n          END IF;\n      \n          RETURN v_table_ddl;\n        \n          EXCEPTION\n          WHEN others THEN\n          BEGIN\n            GET STACKED DIAGNOSTICS v_diag1 = MESSAGE_TEXT, v_diag2 = PG_EXCEPTION_DETAIL, v_diag3 = PG_EXCEPTION_HINT, v_diag4 = RETURNED_SQLSTATE, v_diag5 = PG_CONTEXT, v_diag6 = PG_EXCEPTION_CONTEXT;\n            -- v_ret := 'line=' || v_diag6 || '. '|| v_diag4 || '. ' || v_diag1 || ' .' || v_diag2 || ' .' || v_diag3;\n            v_ret := 'line=' || v_diag6 || '. '|| v_diag4 || '. ' || v_diag1;\n            RAISE EXCEPTION '%', v_ret;\n            -- put additional coding here if necessarY\n            RETURN '';\n          END;\n      \n        END;\n      $$;",{compress:!0,removeAll:!0});(a=_||(_={})).NO_ACTION="a",a.RESTRICT="r",a.CASCADE="c",a.SET_NULL="n",a.SET_DEFAULT="d"},9015:function(e,n,t){var a=t(52322),_=t(64266),r=t(2784),i=t(46318);let c=e=>{var n,t,c;let{defaultActiveId:l,activeId:s,type:E="pills",size:d="tiny",block:o,onChange:p,onClick:N,scrollable:m,wrappable:v,addOnBefore:T,addOnAfter:I,listClassNames:b,baseClassNames:g,refs:u,children:f}=e,S=r.Children.toArray(f),[h,O]=(0,r.useState)(null!==(c=null!=s?s:l)&&void 0!==c?c:null==S?void 0:null===(t=S[0])||void 0===t?void 0:null===(n=t.props)||void 0===n?void 0:n.id);(0,r.useMemo)(()=>{s&&s!==h&&O(s)},[s]);let A=(0,i.Z)("tabs");function R(e){null==N||N(e),e!==h&&(null==p||p(e),O(e))}let L=[A[E].list];return m&&L.push(A.scrollable),v&&L.push(A.wrappable),b&&L.push(b),(0,a.jsxs)(_.fC,{value:h,className:[A.base,g].join(" "),ref:null==u?void 0:u.base,children:[(0,a.jsxs)(_.aV,{className:L.join(" "),ref:null==u?void 0:u.list,children:[T,S.map(e=>{let n=h===e.props.id,t=[A[E].base,A.size[d]];return n?t.push(A[E].active):t.push(A[E].inactive),o&&t.push(A.block),(0,a.jsxs)(_.xz,{onKeyDown:n=>{"Enter"===n.key&&(n.preventDefault(),R(e.props.id))},onClick:()=>R(e.props.id),value:e.props.id,className:t.join(" "),children:[e.props.icon,(0,a.jsx)("span",{children:e.props.label}),e.props.iconRight]},"".concat(e.props.id,"-tab-button"))}),I]}),S]})};c.Panel=e=>{let{children:n,id:t,className:r}=e,c=(0,i.Z)("tabs");return(0,a.jsx)(_.VY,{value:t,className:[c.content,r].join(" "),children:n})},n.Z=c},55283:function(e,n,t){t.d(n,{Fw:function(){return i},wy:function(){return r},zF:function(){return _}});var a=t(69557);let _=a.fC,r=a.wy,i=a.Fw}}]);